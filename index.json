[{"categories":null,"contents":"Bán hàng đạt doanh số cao trên Shopee là mong đợi của rất nhiều nhà bán hàng khi kinh doanh trên sàn thương mai điện tử này.\nCó rất nhiều chiến lược được nhiều nhà bán hàng chia sẻ với nhau để kinh doanh thành công với Shopee.\nVí dụ như bạn sẽ rất hay nhận được rất nhiều lời nhắn, comment mời chào dịch vụ tăng follow trên Shopee với giá chỉ vài trăm đồng.\n]\nTrong bài viết này, chúng ta sẽ cùng bàn luận đến một chiến lược hay thủ thuật mà rất nhiều nhà bán hàng được mời chào sử dụng trong quá trình kinh doanh trên sàn.\nChúng ta đang đề cấp đến việc tăng lượng follow ảo trên Shopee hay Mua lượt theo dõi trên sàn Shopee.\nLợi ích của việc tăng follow gian hàng Shopee? Để đánh giá được liệu việc mua follow trên Shopee có thật sự hữu ích hay không, chúng ta cần biết được lý do tại sao chúng ta cần tăng lượt follow này. Vậy câu hỏi đặt ra ở đây là:\n Tăng follow trên Shopee sẽ mang lại lợi ích gì?\n Mục tiêu của hầu hết nhà bán hàng đều mong muốn là tăng lợi nhuận khi kinh doanh trên sàn Shopee.\nMột trong những yếu tố giúp tăng doanh số bán hàng chính là việc khuyến khích khách hàng thường xuyên truy cập gian hàng và mua sắm nhiều lần.\nNếu khách hàng follow hay theo dõi gian hàng, họ sẽ nhận được nhiều tin nhắn từ gian hàng nhiều hơn cũng như các sản phẩm trong gian hàng cũng được ưu tiên hiển thị cho khách.\nNếu bạn có một lượng lớn theo dõi gian hàng, khi cập nhật bản tin gian hàng hay gửi tin nhắn hàng loạt đến khách hàng, chắc chắn bạn sẽ tiếp cận được nhiều khách hàng hơn các shop chỉ có ít lượt theo dõi.\nBên cạnh đó, tương tự như những nền tảng khác, Shopee sẽ đề xuất các sản phẩm của gian hàng đến những đối tượng có cùng hành vi mua sắm với đối tượng khách hàng đã follow gian hàng của bạn.\nNếu khách A hay mua sản phẩm tại gian hàng của bạn và đã theo dõi gian hàng. Shopee sẽ đề xuất sản phẩm của bạn cho khách B,C,D, … có cùng hành vi với khách A.\nViệc này rất có lợi cho shop vì tiếp cận đến đúng mục tiêu khách hàng sẽ giúp cho tỷ lệ mua hàng được cải thiện hơn rất nhiều. Chúng ta có thể thấy rằng việc tăng lượng theo dõi gian hàng hoàn toàn có lợi cho shop trong việc gia tăng doanh số bán hàng và lợi nhuận.\nMua lượt follow ảo gian hàng trên Shopee có thật sự hữu ích? Ở phần trên, chúng ta đã biết lợi ích của việc tăng follow ảo cho gian hàng.\nCâu hỏi lớn ở phần này là:\n “Việc mua lượt follow ảo gian hàng có mang lại lợi ích như cách tăng lượt follow gian hàng thông thường?”\n Đầu tiên, chúng ta cần biết bản chất của lượt follow ảo là gì.\nCác lượt follow ảo trên Shopee gần như là những tài khoản bot (máy) không phải người mua hàng thực.\nCác tài khoản này được tạo ra nhằm mục đích để bán cho các Shop nhằm tăng chỉ số lượng follow gian hàng mà không có bất kỳ hoạt động mua sắm nào.\nTừ đây bạn có thể biết được những ảnh hưởng nào đến gian hàng trên khi:\n Đăng bản tin dạo Chạy quảng cáo Thực hiện livestream trên sàn Đề xuất sản phẩm dựa trên hành vi người dùng Tham gia các chương trình khuyến mãi lớn từ sàn.  Nếu bạn mua lượng follower ảo trên Shopee, thuật toán sẽ đề xuất các sản phẩm trong gian hàng đến những nhóm đối tượng có cùng hành vi với lượng follower ảo này.\nLượng follower ảo không có hoạt động mua sắm, đồng nghĩa với gian hàng của bạn ngày càng tiếp cận sai đối tượng mua hàng.\nNhư vậy, lợi ích của việc mua lượng follower ảo trên Shopee ngoài việc làm đẹp các chỉ số của gian hàng, không những không có tác dụng giúp tăng doanh số mà có thể góp phần làm doanh số gian hàng suy giảm trong tương lai.\nThế nào là một follwer chất lượng? Chúng ta vừa đề cập ở phần trên về tác hại của việc mua lượt follower ảo vì tính không hiệu quả của nó. Để có thể xây dựng được tệp khách hàng theo dõi gian hàng chất lượng, chúng ta cần biết một follower chất lượng là gì.\nTheo mình, yếu tố quan trọng nhất của một follower chất lượng phải là người thật.\nĐiều này có nghĩ follower này cần phải có lịch sử mua hàng.\nSẽ tốt hơn nếu khách hàng này có lịch sử mua hàng thật nhiều trên Shopee. Càng nhiều dữ liệu, thuật toán của shopee sẽ giúp gian hàng của bạn được đề xuất đến nhóm đối tượng phù hợp hơn.\nTương tự như khi bạn sử dụng các công cụ, tính năng hay tham gia các chương trình khuyến mãi của sàn, những khách hàng mới được tiếp cận chính xác hơn giúp bạn dễ dàng tăng doanh số bán hàng.\nLời kết Đầu tiên, bạn cần nói không trong việc gia tăng lượng khách theo dõi gian hàng bằng cách mua follower ảo trên gian hàng.\nĐể phát triển bền vững, bạn cần thu hút đúng đối tượng khách hàng của gian hàng.\nNếu bạn làm đúng được việc này, nhiều khách hàng chất lượng sẽ tiếp cận với gian hàng của bạn nhiều hơn trong tương lai.\nVậy làm thế nào để tăng lượng follower trên gian hàng một cách tự nhiên nhưng hiệu quả? Đây là chủ đề mình sẽ bàn luận trong một bài viếc khác nhé.\n","date":"17","image":"/images/BaiViet1.jpg","permalink":"https://ecomblog.onpoint.vn/blog/20210917_baiviet1/","tags":["OnPoint","Tangfollow","Banhangshopee"],"title":"Mua lượt follow ảo trên Shopee - Nên hay không?"},{"categories":null,"contents":"Say hello to Onpoint ","date":"15","image":"/img/tarams-parse.png","permalink":"https://ecomblog.onpoint.vn/blog/2021-09-15-hello-onpoint/","tags":["onpoint","ecommerce"],"title":"Say hello to OnPoint"},{"categories":null,"contents":"If your data is encrypted, even if it\u0026rsquo;s leaked, no one know what is the data. That\u0026rsquo;s great.\nIn this post, I\u0026rsquo;m going to show you how to encrypt data with Ecto. Ecto allows developer to define their own types. And we will define a type called EncryptedText which encrypts data before persiting to database and decrypts data after loading.\n1. Define encrypt/decrypt methods This is a simple version of crypto module:\n1defmodule Crypto do 2 @block_size 16 3 4 def generate_secret do 5 :crypto.strong_rand_bytes(@block_size) 6 |\u0026gt; Base.encode64() 7 end 8 9 def encrypt(plaintext, secret_key) do 10 with {:ok, secret_key} \u0026lt;- decode_key(secret_key) do 11 iv = :crypto.strong_rand_bytes(@block_size) 12 plaintext = pad(plaintext, @block_size) 13 ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true) 14 15 {:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)} 16 end 17 end 18 19 def decrypt(ciphertext, secret_key) do 20 with {:ok, secret_key} \u0026lt;- decode_key(secret_key), 21 {:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) do 22 plaintext = 23 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 24 |\u0026gt; unpad 25 26 {:ok, plaintext} 27 else 28 {:error, _} = err -\u0026gt; err 29 _ -\u0026gt; {:error, \u0026#34;Bad encrypted data\u0026#34;} 30 end 31 end 32 33 defp pad(data, block_size) do 34 to_add = block_size - rem(byte_size(data), block_size) 35 data \u0026lt;\u0026gt; :binary.copy(\u0026lt;\u0026lt;to_add\u0026gt;\u0026gt;, to_add) 36 end 37 38 defp unpad(data) do 39 to_remove = :binary.last(data) 40 :binary.part(data, 0, byte_size(data) - to_remove) 41 end 42end Let go through the code\n1 def generate_secret do 2 :crypto.strong_rand_bytes(@block_size) 3 |\u0026gt; Base.encode64() 4 end This function generate a 16 bytes secret key and encode base 64 string so you can add it to config.\n encrypt/2 function  1 def encrypt(plaintext, secret_key) do 2 # check the key size 3 with {:ok, secret_key} \u0026lt;- decode_key(secret_key) do 4 5 # random initial vector 6 iv = :crypto.strong_rand_bytes(@block_size) 7 # if length of text is not multiple of @block_size 8 # we add more data until it meets condition 9 plaintext = pad(plaintext, @block_size) 10 # encrypt here 11 ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true) 12 13 {:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)} 14 end 15 end This is the most important line\n1ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true)  iv is initial vector. AES-128 algorithms encrypts data by block of 16 bytes, so we need initial vector to make sure that the output of blocks with same data are different from each other. The last parameter is set to true to encrypt, set to false to decrypt data  And then we encode output to base 64 string. Here we concatenate iv and ciphertext so that we can extract iv to use for decrypting\n1{:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)}  decrypt/2 function  1def decrypt(ciphertext, secret_key) do 2 # check the key 3 with {:ok, secret_key} \u0026lt;- decode_key(secret_key), 4 {:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) do 5 plaintext = 6 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 7 |\u0026gt; unpad 8 9 {:ok, plaintext} 10 else 11 {:error, _} = err -\u0026gt; err 12 _ -\u0026gt; {:error, \u0026#34;Bad encrypted data\u0026#34;} 13 end 14 end We extract iv and encrypted data from input\n1{:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) We use pattern matching to extract first 16 byte and assign to iv and assign remaining data to ciphertext. Then decrypting data\n1plaintext = 2 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 3 |\u0026gt; unpad This line is similar to the line which encrypts data, the difference is here we replace plaintext by ciphertext and last parameter is set to false. After data is decrypted, we need to remove padding to get the original data.\n2. Build EncryptedText type I define a type to store binary data, you can define a EncryptedMap to store map data. The most important function are dump and load where we encrypt before persisting and decrypt after loading.\n1defmodule EncryptedText do 2 use Ecto.Type 3 4 # we store data as string 5 def type, do: :string 6 7 def cast(value) when is_binary(value) do 8 {:ok, value} 9 end 10 def cast(_), do: :error 11 12 def dump(nil), do: nil 13 # encrypt data before persist to database 14 def dump(data) when is_binary(data) do 15 with {:ok, secret_key} \u0026lt;- Application.fetch_env(:myapp, :ecto_secret_key), 16 {:ok, data} \u0026lt;- Crypto.encrypt(data, secret_key) do 17 {:ok, data} 18 else 19 _ -\u0026gt; :error 20 end 21 end 22 23 def dump(_), do: :error 24 25 def load(nil), do: nil 26 # decrypt data after loaded from database 27 def load(data) when is_binary(data) do 28 secret_key = Application.fetch_env!(:myapp, :ecto_secret_key) 29 case Crypto.decrypt(data, secret_key) do 30 {:error, _} -\u0026gt; :error 31 ok -\u0026gt; ok 32 end 33 end 34 35 def load(_), do: :error 36 37 def embed_as(_), do: :dump 38end 39 3. Use it in your schema  You must add secret key to your app config first.  1config :myapp, :ecto_secret_key, \u0026#34;your key using Crypto.generate_secret\u0026#34;  Add to schema  1schema \u0026#34;users\u0026#34; do 2 field :name, :string 3 ... 4 field :secret, EncryptedText 5 ... 6end Your data are safe now.\n4. Conclusion With Crypto you can implement encrypted field for any type of data you want.\nThere is an issue when you want to change your secret key, you have to load your data row by row, decrypt and then encrypt with new key and update to database.\nI found this article which explains very well about crypto if you are interested https://www.thegreatcodeadventure.com/elixir-encryption-with-erlang-crypto/ Although she uses old crypto API so it will throw some warnings.\nI implemented encrypted type for text and map for my company project here if you want to use it:\nGithub\nThanks for reading.\n","date":"20","image":"/img/encrypt-data-ecto.png","permalink":"https://ecomblog.onpoint.vn/blog/2021-08-20-encrypt-data-with-ecto/","tags":["elixir","ecto","crypto"],"title":"How to encrypt your data with Ecto"},{"categories":null,"contents":"Khi viết các API hoặc cả các endpoint thì thông thường chúng ta sẽ có một số nhu cầu:\n Chỉ cho phép một số các tham số xác định được truyền vào. Chuyển các tham số về kiểu dữ liệu mong muốn Validate các tham số theo yêu cầu  Bài viết này sẽ hướng dẫn các bạn giải quyết các vấn đề trên sử dụng Ecto.Changeset\nThư viện Ecto đã cung cấp sẵn cho chúng ta module Changeset. Nó hỗ trợ việc cast các tham số về đúng kiểu dữ liệu mong muốn, nó cũng hỗ trợ các phương thức để validate các tham số yêu cầu, và nó cũng cho phép bạn giới hạn tham số nào được truyền vào.\nVà sau đây là một ví dụ sử dụng Chageset để validate các tham số khi filter các đơn hàng.\n1. Đầu tiên bạn phải định nghĩa một schema 1defmodule MyApp.OrderFilterParams do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 schema \u0026#34;order_filter_params\u0026#34; do 6 field :keyword, :string 7 field :category_id, :integer 8 field :status, :string 9 field :start_date, :utc_datetime 10 field :end_date, :utc_datetime 11 end 12end 2. Cast và validate Sau đó phải định nghĩa một hàm để thực hiện việc cast tham số và validate changeset.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 @required ~w(category_id start_date) 6 @optional ~w(keyword status end_date) 7 8 def changeset(changeset_or_model, params) do 9 cast(changeset_or_model, params, @required ++ @optional) 10 |\u0026gt; validate_required(@required) 11 end 12end 3. Set giá trị default động Nếu bạn muốn sử dụng các giá trị default động, ví dụ như mặc định ngày kết thúc là ngày hiện tại, các bạn phải định nghĩa một function để set giá trị mong muốn.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 def changeset(changeset_or_model, params) do 6 cast(changeset_or_model, params, @required ++ @optional) 7 |\u0026gt; validate_required(@required) 8 |\u0026gt; set_default_end_date() 9 end 10 11 defp set_defaut_end_date(changeset) do 12 end_date = get_change(changeset, :end_date) 13 if is_nil(end_date) do 14 put_change(changeset, :end_date, Timex.today()) 15 else 16 changeset 17 end 18 end 19end 4. Sử dụng Params schema 1defmodule MyApp.OrderController do 2 use MyApp, :controller 3 alias MyApp.OrderFilterParams 4 5 def index(conn, params) do 6 changeset = OrderFilterParams.changeset(%OrderFilterParams{}, params) 7 8 if changeset.valid? do 9 strong_params = Ecto.Changeset.apply_changes(changeset) 10\tIO.put(strong_params.keyword) 11 # Do something with your params 12 else 13 # handle error 14 end 15 end 16end 17 Rất đơn giản đúng không, nếu bạn đã sử dụng Ecto thì việc này chỉ là ruồi muỗi. Tuy nhiên đơn giản thì phải có thứ đánh đổi chứ.\nVài thứ mà bạn sẽ thấy bất tiện 1. Lượng code mà bạn phải viết quá nhiều. Thử tưởng tượng mỗi API bạn lại phải định nghĩa thêm một Module params cho nó thì phức tạp vl.\nBạn có thể sử dụng schemaless, nhưng mà function của bạn sẽ rối nùi lên vì code logic và code xử lý params nó không liên quan gì tới nhau cả. Và bạn thì kiểu như đổ sting vào cơm để ăn vậy.\n2. Thiếu linh hoạt. Điều này cũng đúng vì mục đích chính của Ecto là phục vụ cho việc định nghĩa các schema cho database.\nĐơn giản như việc định nghĩa giá trị default động như trên, bạn phải viết luôn 1 hàm mới\nTuy nhiên nó cũng có một ưu điểm là bạn không phải sử dụng thêm thư viện của bên thứ ba.\nKết Nếu bạn không cần phải xử lý nhiều ràng buộc liên quan đến tham số của request thì đơn giản là cứ dùng Changeset thôi.\nNếu bạn muốn nhanh gọn hơn thì trên Hex có một số thư viện để hỗ trợ định nghĩa param đơn giản hơn, ví dụ như https://github.com/bluzky/tarams/\nThư viện này cung cấp cách thức đơn giản và nhanh chóng hơn để định nghĩa param cho API. Mình sẽ viết bài hướng dẫn sau.\n","date":"26","image":"/img/parse-ecto-phoenix.png","permalink":"https://ecomblog.onpoint.vn/blog/validate-request-params-phoenix-ecto/","tags":["elixir","ecto","phoenix"],"title":"Parse và validate request param trong Phoenix với Ecto"}]